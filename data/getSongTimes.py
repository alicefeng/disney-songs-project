# -*- coding: utf-8 -*-
"""
Title: getSongTimes.py

This program takes the subtitle datasets generated by createSubsData.py
for each Disney feature animation and matches each line against lyrics
from songs in that film to determine the start and end time of every song.  

Inputs:
animated_list.csv
song_lyrics.csv
subtitle files for each Disney animated feature film

Output:
(a dataset with the start and end times of each song)

Date Created: Oct. 30, 2016

Author: Alice Feng
"""

#import os
import pandas as pd
import numpy as np
import string
import datetime


# reduce the subtitle dataset if possible to just the lines that are sung
def minimize_subdata(film, song_lyrics):
    data = pd.read_csv(film + '.csv')

    # for subs that denote a sung line using an eighth note (special character)    
    if film in ['Pinocchio']:
        subdata = data.loc[data.text.str.startswith("\xe2\x99\xaa", na=False)]
    # for subs that say "(SINGING)" at the start of the first sung line,
    # identify the line and grab the next few lines after it (positional)
#    elif film in ['Snow White and the Seven Dwarfs']:
#        lines = []
#        for i in range(len(data)):
#            if "(SINGING)" in data.text[i]:
#                if (i+max(song_lyrics.Line_num)+5) < len(data):
#                    lines.extend(range(i, i+max(song_lyrics.Line_num)+5))
#                else:
#                    lines.extend(range(i, len(data)))
#        lines = list(set(lines))
#        subdata = data.iloc[lines, :]
    else:
        subdata = data
    
    # reset index
    subdata.index = range(len(subdata))
    return subdata
                

# write a line matching function
def line_match(sub_line, lyric_line):
    # first clean the lines
    sub_clean = sub_line.lower().translate(string.maketrans("",""), string.punctuation).strip("\xe2\x99\xaa")
    lyric_clean = lyric_line.lower().translate(string.maketrans("",""), string.punctuation)
    
    # if subtitle and lyric lines are identical
    if sub_clean == lyric_clean:
        return 1
    # if lyric line has more words than the subtitle or vice versa 
    # but the words that overlap match perfectly
    elif (sub_clean in lyric_clean) or (lyric_clean in sub_clean):
        return 1
    else:
        # get overlap using bag of words
        sub_words = sub_clean.split()
        lyric_words = lyric_clean.split()
        common = list(set(sub_words) & set(lyric_words))

        # get ratio of commmon words to all words in the sub or lyrics 
        # (depending on which is shorter)        
        if len(sub_words) < len(lyric_words):
            return float(len(common))/len(sub_words)
        else:
            return float(len(common))/len(lyric_words)
   
    
    
    
# read in data
disney_films = pd.read_csv('animated_list.csv')
song_lyrics = pd.read_csv('song_lyrics.csv')
    
films = ['Snow White and the Seven Dwarfs', 'Pinocchio']
match = []
    
for film in films:
    subdata = minimize_subdata(film, song_lyrics)    
    lyricdata = song_lyrics[song_lyrics.Film == film]
    
        
    # try matching each line in the subs with a line from any of the songs
    for i in range(len(subdata)):
        for line in lyricdata.Lyric:
            # only match on lines with more than 2 words to reduce false positives
            if len(subdata.text[i].split()) > 2 and len(line.split()) > 2:
                match_prob = line_match(subdata.text[i], line)
                if match_prob > 0.75:
                    song = lyricdata.Song_Title[lyricdata.Lyric == line].values[0]
                    match.append({'Film': film,
                                  'Sub_no': subdata.sub_no[i], 
                                  'Subtitle': subdata.text[i],
                                  'Lyric': line,
                                  'Song': song,
                                  'Start_time': subdata.start_time[i],
                                  'End_time': subdata.end_time[i]}) 
    
    match_df = pd.DataFrame(match, columns=['Film', 'Sub_no', 'Subtitle', 'Lyric',
                                            'Song', 'Start_time', 'End_time'])
    
    # add a song number to each song in order of appearance to catch reprises
    match_df.sort_values(by=['Film', 'Start_time'], inplace=True)
    match_df.index = range(1, len(match_df) + 1)
    
    match_df.loc[:, 'Prev_end_time'] = match_df['End_time'].shift(1)
    match_df.loc[:, 'Time_diff'] = (pd.to_datetime(match_df.Start_time, format='%H:%M:%S,%f') - pd.to_datetime(match_df.Prev_end_time, format='%H:%M:%S,%f'))/np.timedelta64(1, 's')
    
    match_df.loc[:, 'Song_num'] = 1
    for i in range(2, len(match_df) + 1):
        # restart the song number for each movie        
        if match_df['Film'][i] != match_df['Film'][i-1]:
            match_df['Song_num'][i] = 1
        # in case the song title is the same but there's been too long a gap 
        # between current and previous line, treat as a new song (reprise)
        elif match_df['Time_diff'][i] > 60:
            match_df['Song_num'][i] = match_df['Song_num'][i-1] + 1
        # new song number when the song name changes
        elif match_df['Song'][i] != match_df['Song'][i-1]:
            match_df['Song_num'][i] = match_df['Song_num'][i-1] + 1
        else:
            match_df['Song_num'][i] = match_df['Song_num'][i-1]

                                            
    # get start and end times of each song
    song_times = match_df.groupby(by=['Film', 'Song', 'Song_num'], 
                                  as_index=False).agg({'Start_time': min, 'End_time': max})
    
    # calculate length of each song
    song_times['Length'] = pd.to_datetime(song_times.End_time, format='%H:%M:%S,%f') - pd.to_datetime(song_times.Start_time, format='%H:%M:%S,%f')
    
    # sort song_times by film and song start time
    song_times.sort_values(by=['Film', 'Start_time'], inplace=True)
    
    # remove "songs" with length of < 10 sec
    song_times = song_times[song_times.Length > datetime.timedelta(seconds=10)]